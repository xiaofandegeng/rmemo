name: Release Please

on:
  push:
    branches:
      - main
  workflow_dispatch: {}

permissions:
  contents: write
  pull-requests: write

jobs:
  release-please:
    runs-on: ubuntu-latest
    concurrency:
      group: release-please
      cancel-in-progress: true
    outputs:
      releases_created: ${{ steps.release-result.outputs.releases_created }}
    steps:
      - id: release-try-1
        uses: googleapis/release-please-action@v4
        continue-on-error: true
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          config-file: release-please-config.json
          manifest-file: .release-please-manifest.json
      - id: release-try-2
        if: steps.release-try-1.outcome == 'failure'
        uses: googleapis/release-please-action@v4
        continue-on-error: true
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          config-file: release-please-config.json
          manifest-file: .release-please-manifest.json
      - id: release-result
        shell: bash
        run: |
          FIRST_STATUS="${{ steps.release-try-1.outcome }}"
          SECOND_STATUS="${{ steps.release-try-2.outcome }}"
          FIRST_RELEASES_CREATED="${{ steps.release-try-1.outputs.releases_created }}"
          SECOND_RELEASES_CREATED="${{ steps.release-try-2.outputs.releases_created }}"

          if [[ "$FIRST_STATUS" == "success" ]]; then
            echo "releases_created=${FIRST_RELEASES_CREATED}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [[ "$SECOND_STATUS" == "success" ]]; then
            echo "releases_created=${SECOND_RELEASES_CREATED}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "release-please failed twice (attempt-1=${FIRST_STATUS}, attempt-2=${SECOND_STATUS:-skipped})."
          exit 1

  publish-from-release-please:
    needs: release-please
    if: needs.release-please.outputs.releases_created == 'true'
    runs-on: ubuntu-latest
    env:
      RELEASE_HEALTH_TIMEOUT_MS: "15000"
      RELEASE_HEALTH_GITHUB_RETRIES: "2"
      RELEASE_HEALTH_GITHUB_RETRY_DELAY_MS: "1000"
      RELEASE_READY_STEP_TIMEOUT_MS: "120000"
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: 22
          registry-url: "https://registry.npmjs.org"

      - name: Resolve version + dist-tag
        id: vars
        run: |
          VERSION="$(node -p "require('./package.json').version")"
          DIST_TAG="latest"
          if echo "$VERSION" | grep -q '-'; then
            DIST_TAG="next"
          fi
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "dist_tag=$DIST_TAG" >> "$GITHUB_OUTPUT"

      - name: Run tests
        run: node --test

      - name: Changelog lint
        run: npm run verify:changelog

      - name: Contract drift check
        run: node bin/rmemo.js contract check --format json --fail-on any

      - name: Regression matrix check
        run: npm run verify:matrix

      - name: Publish to npm (skip if already published)
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
          npm_config_cache: .npm-cache
        run: |
          PKG="$(node -p "require('./package.json').name")"
          V="${{ steps.vars.outputs.version }}"
          if npm view "$PKG@$V" version >/dev/null 2>&1; then
            echo "Already published: $PKG@$V (skipping)"
            exit 0
          fi
          npm whoami
          npm publish --tag "${{ steps.vars.outputs.dist_tag }}"

      - name: Build npm tarball (for release assets)
        run: npm_config_cache=.npm-cache npm pack

      - name: Generate release notes from changelog
        run: |
          mkdir -p artifacts
          node scripts/release-notes.js --version "${{ steps.vars.outputs.version }}" --out artifacts/release-notes.md

      - name: Sync GitHub Release body from changelog section
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require("fs");
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const tag = "v${{ steps.vars.outputs.version }}";
            const notesPath = "artifacts/release-notes.md";
            if (!fs.existsSync(notesPath)) {
              core.warning(`Missing ${notesPath}, skip release body sync.`);
              return;
            }
            const notes = fs.readFileSync(notesPath, "utf8").trim();
            if (!notes) {
              core.warning("release notes is empty, skip release body sync.");
              return;
            }
            let rel;
            try {
              rel = await github.rest.repos.getReleaseByTag({ owner, repo, tag });
            } catch (e) {
              core.warning(`Release ${tag} not found, skip body sync.`);
              return;
            }
            const current = String(rel.data.body || "");
            const placeholder = !current.trim() || /^Full Changelog:/m.test(current.trim());
            if (!placeholder) {
              core.info("Release body is non-empty and not placeholder, keep existing body.");
              return;
            }
            await github.rest.repos.updateRelease({
              owner,
              repo,
              release_id: rel.data.id,
              body: notes
            });
            core.info(`Updated release body for ${tag} from CHANGELOG.`);

      - name: Upload release assets (tgz)
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require("fs");
            const path = require("path");
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const tag = "v${{ steps.vars.outputs.version }}";
            const version = "${{ steps.vars.outputs.version }}";
            
            // Try to find the release matching the tag created by release-please
            let release_id;
            try {
              const rel = await github.rest.repos.getReleaseByTag({ owner, repo, tag });
              release_id = rel.data.id;
            } catch (e) {
              core.warning(`Release ${tag} not found. Ensure release-please created it.`);
              return;
            }

            const files = fs.readdirSync(process.cwd()).filter((f) => f.endsWith(".tgz"));
            if (!files.length) {
              core.info("No .tgz files found to upload.");
              return;
            }

            const pkg = JSON.parse(fs.readFileSync(path.join(process.cwd(), "package.json"), "utf8"));
            const { pathToFileURL } = require("url");
            const helperUrl = pathToFileURL(path.join(process.cwd(), "scripts", "release-asset-names.js")).href;
            const { deriveReleaseAssetNames } = await import(helperUrl);
            const { scopedPackFile, expectedAsset: preferredAssetName } = deriveReleaseAssetNames({
              packageName: String(pkg.name || ""),
              version
            });

            const assets = await github.paginate(github.rest.repos.listReleaseAssets, { owner, repo, release_id, per_page: 100 });
            const byName = new Map(assets.map((a) => [a.name, a]));

            for (const f of files) {
              const assetName = f === scopedPackFile ? preferredAssetName : f;
              const namesToDelete = new Set([f, assetName]);
              for (const name of namesToDelete) {
                const existing = byName.get(name);
                if (!existing) continue;
                core.info(`Deleting existing asset: ${name}`);
                await github.rest.repos.deleteReleaseAsset({ owner, repo, asset_id: existing.id });
                byName.delete(name);
              }
              const data = fs.readFileSync(path.join(process.cwd(), f));
              core.info(`Uploading asset: ${assetName} (source: ${f}, bytes: ${data.length})`);
              await github.rest.repos.uploadReleaseAsset({
                owner,
                repo,
                release_id,
                name: assetName,
                data,
                headers: {
                  "content-type": "application/octet-stream",
                  "content-length": data.length
                }
              });
            }

      - name: Verify Publish Success (Post-Release)
        run: |
          PKG="$(node -p "require('./package.json').name")"
          V="${{ steps.vars.outputs.version }}"
          echo "Verifying $PKG@$V exists on NPM registry..."
          
          # We retry max 5 times, sleeping 10s between checks to allow NPM CDN propagation
          for i in 1 2 3 4 5; do
            if npm view "$PKG@$V" version >/dev/null 2>&1; then
              echo "✅ Successfully verified $PKG@$V is published."
              exit 0
            fi
            echo "Waiting for NPM to register $V (attempt $i/5)..."
            sleep 10
          done
          echo "❌ Failed to verify $PKG@$V on NPM."
          exit 1

      - name: Post-publish install smoke test
        env:
          npm_config_cache: .npm-cache
        run: |
          PKG="$(node -p "require('./package.json').name")"
          V="${{ steps.vars.outputs.version }}"
          TMP_DIR="$(mktemp -d)"
          INSTALL_DIR="$(mktemp -d)"
          BIN="$INSTALL_DIR/node_modules/.bin/rmemo"
          smoke() {
            rm -rf "$INSTALL_DIR/node_modules" "$INSTALL_DIR/package-lock.json"
            npm install --prefix "$INSTALL_DIR" --no-audit --no-fund "$PKG@$V" >/dev/null
            "$BIN" --help >/dev/null
            "$BIN" --root "$TMP_DIR" init >/dev/null
            "$BIN" --root "$TMP_DIR" status --format json > "$TMP_DIR/status.json"
          }
          for i in 1 2 3; do
            if smoke; then
              break
            fi
            if [ "$i" -eq 3 ]; then
              echo "❌ Post-publish smoke test failed after $i attempts."
              exit 1
            fi
            echo "Smoke test not ready yet (attempt $i/3), retrying in 10s..."
            sleep 10
          done
          node -e "const fs=require('fs'); const data=JSON.parse(fs.readFileSync(process.argv[1], 'utf8')); if (!data || typeof data.root !== 'string') { throw new Error('invalid status payload'); }" "$TMP_DIR/status.json"

      - name: Release health check
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          node scripts/release-health.js --format md --version "${{ steps.vars.outputs.version }}" --tag "v${{ steps.vars.outputs.version }}" --allow-legacy-scoped-asset false --timeout-ms "${RELEASE_HEALTH_TIMEOUT_MS}" --github-retries "${RELEASE_HEALTH_GITHUB_RETRIES}" --github-retry-delay-ms "${RELEASE_HEALTH_GITHUB_RETRY_DELAY_MS}"

      - name: Generate release audit reports
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          mkdir -p artifacts
          node scripts/release-health.js --format json --version "${{ steps.vars.outputs.version }}" --tag "v${{ steps.vars.outputs.version }}" --repo "${{ github.repository }}" --allow-legacy-scoped-asset false --timeout-ms "${RELEASE_HEALTH_TIMEOUT_MS}" --github-retries "${RELEASE_HEALTH_GITHUB_RETRIES}" --github-retry-delay-ms "${RELEASE_HEALTH_GITHUB_RETRY_DELAY_MS}" > artifacts/release-health.json
          node scripts/release-ready.js --format md --skip-tests --allow-dirty --step-timeout-ms "${RELEASE_READY_STEP_TIMEOUT_MS}" --out artifacts/release-ready.md
          node scripts/release-ready.js --format json --skip-tests --allow-dirty --step-timeout-ms "${RELEASE_READY_STEP_TIMEOUT_MS}" --out artifacts/release-ready.json

      - name: Upload release audit artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: rmemo-release-audit-${{ steps.vars.outputs.version || 'unknown' }}
          path: |
            artifacts/release-notes.md
            artifacts/release-health.json
            artifacts/release-ready.md
            artifacts/release-ready.json
          if-no-files-found: warn
          retention-days: 30

      - name: Collect diagnostics on failure
        if: failure()
        run: |
          mkdir -p artifacts
          node scripts/release-notes.js --version "${{ steps.vars.outputs.version }}" --out artifacts/release-notes.md || echo "release notes generation failed" > artifacts/release-notes.md
          node ./bin/rmemo.js diagnostics export --format json > artifacts/diagnostics.json || echo '{"error":"Failed to run diagnostics export"}' > artifacts/diagnostics.json
          node ./bin/rmemo.js contract check --format json --fail-on any > artifacts/contract-check.json || echo '{"error":"Failed to run contract check"}' > artifacts/contract-check.json
          npm run verify:matrix -- --format json > artifacts/regression-matrix.json || echo '{"error":"Failed to run regression matrix"}' > artifacts/regression-matrix.json
          node scripts/release-health.js --format json --version "${{ steps.vars.outputs.version }}" --tag "v${{ steps.vars.outputs.version }}" --allow-legacy-scoped-asset false --timeout-ms "${RELEASE_HEALTH_TIMEOUT_MS}" --github-retries "${RELEASE_HEALTH_GITHUB_RETRIES}" --github-retry-delay-ms "${RELEASE_HEALTH_GITHUB_RETRY_DELAY_MS}" > artifacts/release-health.json || echo '{"error":"Failed to run release health"}' > artifacts/release-health.json

      - name: Upload failure diagnostics artifact
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: rmemo-release-diagnostics-${{ steps.vars.outputs.version || 'unknown' }}
          path: artifacts/
          if-no-files-found: warn
          retention-days: 30
