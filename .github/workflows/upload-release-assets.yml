name: Upload Release Assets

on:
  workflow_dispatch:
    inputs:
      tag:
        description: "Tag to upload assets for (e.g. v0.3.1)"
        required: true
        type: string

permissions:
  contents: write

jobs:
  upload:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ inputs.tag }}

      - uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: Build npm tarball
        run: npm_config_cache=.npm-cache npm pack

      - name: Upload .tgz assets to GitHub Release
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require("fs");
            const path = require("path");
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const tag = "${{ inputs.tag }}";

            function stripV(t) {
              return String(t || "").replace(/^v/i, "");
            }

            function extractChangelogBody(version) {
              const p = path.join(process.cwd(), "CHANGELOG.md");
              if (!fs.existsSync(p)) return "";
              const s = fs.readFileSync(p, "utf8");
              // Match headings like:
              //   ## 0.3.1
              //   ## [0.3.1]
              //   ## 0.3.1 (2026-02-14)
              const v = String(version).replace(/[.*+?^${}()|[\]\\]/g, "\\\\$&");
              const re = new RegExp(`^##\\\\s*(?:\\\\[)?${v}(?:\\\\])?(?:\\\\s*\\\\([^\\\\n]*\\\\))?\\\\s*$`, "m");
              const m = s.match(re);
              if (!m) return "";
              const start = m.index + m[0].length;
              const rest = s.slice(start);
              const next = rest.match(/^##\\\\s+/m);
              const section = (next ? rest.slice(0, next.index) : rest).trim();
              // Keep the version heading out of the body; GitHub Release already shows tag.
              return section;
            }

            async function ensureRelease() {
              try {
                const rel = await github.rest.repos.getReleaseByTag({ owner, repo, tag });
                return rel.data;
              } catch (e) {
                const status = e?.status || e?.response?.status;
                if (status !== 404) throw e;

                const version = stripV(tag);
                let body = extractChangelogBody(version);
                if (!body) {
                  // Best-effort: ask GitHub to generate notes; if it fails, fall back to empty.
                  try {
                    const notes = await github.rest.repos.generateReleaseNotes({
                      owner,
                      repo,
                      tag_name: tag,
                      name: tag
                    });
                    body = notes?.data?.body || "";
                  } catch (_) {}
                }

                core.info(`Release for ${tag} not found; creating one now...`);
                const created = await github.rest.repos.createRelease({
                  owner,
                  repo,
                  tag_name: tag,
                  name: tag,
                  body: body || "",
                  draft: false,
                  prerelease: false
                });
                return created.data;
              }
            }

            const rel = await ensureRelease();
            const release_id = rel.id;

            const files = fs.readdirSync(process.cwd()).filter((f) => f.endsWith(".tgz"));
            if (!files.length) {
              core.setFailed("No .tgz files found to upload.");
              return;
            }

            const assets = await github.paginate(github.rest.repos.listReleaseAssets, { owner, repo, release_id, per_page: 100 });
            const byName = new Map(assets.map((a) => [a.name, a]));

            for (const f of files) {
              const existing = byName.get(f);
              if (existing) {
                core.info(`Deleting existing asset: ${f}`);
                await github.rest.repos.deleteReleaseAsset({ owner, repo, asset_id: existing.id });
              }
              const data = fs.readFileSync(path.join(process.cwd(), f));
              core.info(`Uploading asset: ${f} (${data.length} bytes)`);
              await github.rest.repos.uploadReleaseAsset({
                owner,
                repo,
                release_id,
                name: f,
                data,
                headers: {
                  "content-type": "application/octet-stream",
                  "content-length": data.length
                }
              });
            }
